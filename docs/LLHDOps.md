---
title: Operations
nav_order: 2
---
{::options toc_levels="1..3" /}

# Operations
{: .no_toc}

1. toc
{:toc}

<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `llhd.and` (llhd::AndOp)

Bitwise AND

Takes two integers of the same width or two nine-valued-logic (IEEE 1164)
values of the same width as input. Calculates the bitwise AND. The 
result is always of the exact same type as the two inputs.

**Syntax:**
```
and-op ::= ssa-id `=` `llhd.and` ssa-lhs `,` ssa-rhs attr-dict `:` type
```

**Examples:**
```
%0 = llhd.const 0 : i32
%1 = llhd.and %0, %0 : i32 
```

**Truth Table for `iN`:**

| `and` |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  0  |
|   1   |  0  |  1  |

**Truth Table for `lN`:**

| `and` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  0  |  U  |  U  |  U  |  0  |  U  |  U  |
|   X   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   0   |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|   1   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   Z   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   W   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   L   |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|   H   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   -   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | signless integer
`rhs` | signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | signless integer

### `llhd.const` (llhd::ConstOp)

Introduce a new constant.

The `llhd.const` instruction introduces a new constant value as an 
SSA-operator.  
Legal types are integers and time. Note: Signals 
are not legal to define using `llhd.const`, use the `llhd.sig` 
instruction for that.

**Custom syntax:**

```
const-op ::= ssa-id `=` `llhd.const` attribute-value attr-dict `:` result-type
```

**Examples:**

```
%0 = llhd.const 1 : i64
%1 = llhd.const #llhd.time<1ns, 2d, 3d> : !llhd.time
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`value` | Attribute | any attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`out` | signless integer or LLHD time type

### `llhd.drv` (llhd::DrvOp)

Drive a value into a signal.

Syntax:

```
operation ::= `llhd.drv` operands attr-dict `:` type(operands)
```


The `llhd.drv` operation drives a new value onto a signal. A time operand
also has to be passed, which specifies the frequency at which the drive
will be performed. This operation does not define any new SSA operands.

**Custom Syntax:**

```
drv-op ::= `llhd.drv` ssa-signal `,` ssa-const `,` ssa-time `:` !llhd.sig<const-type> `,` const-type `,` time-type
```

**Examples:**

```
%init = llhd.const 1 : i1
%time = llhd.const #llhd.time<1ns, 0d, 0e> : !llhd.time
%sig = llhd.sig %init : i1 -> !llhd.sig<i1>
%new = llhd.not %init : i1

llhd.drv %sig, %new, %time : !llhd.sig<i1>, i1, !llhd.time
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`signal` | LLHD sig type
`value` | signless integer
`time` | LLHD time type

### `llhd.entity` (llhd::EntityOp)

Create an entity.

The `llhd.entity` operation defines a new entity unit. An entity 
represents the data-flow description of how a circuit's output values
change in reaction to changing input values.  
An entity contains one region with a single block and an implicit 
`TerminatorOp` terminator. Both the block name and terminator are 
omitted in the custom syntax. No further blocks and control-flow are 
legal inside an entity.

**Custom syntax:**
```
entity-op ::= `llhd.entity` entity-symbol `(` arg-list `)` `->` `(` out-list `)` attr-dict entity-region
```

**Examples:**
```
llhd.entity @Foo () -> () {
    %0 = llhd.const 0 : i1
    %toggle = llhd.sig %0 : i1 -> !llhd.sig<i1>
    %1 = llhd.prb %toggle : !llhd.sig<i1> -> i1
    %2 = llhd.not %1 : i1
    %dt = llhd.const #llhd.time<1ns, 0d, 0e> : !llhd.time
    llhd.drv %toggle, %2, %dt : !llhd.sig<i1>, i1, !llhd.time
}
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`ins` | IntegerAttr | 64-bit signless integer attribute

### `llhd.halt` (llhd::HaltOp)

Terminates execution of a process.

Syntax:

```
operation ::= `llhd.halt` attr-dict
```


The `halt` instruction terminates execution of a process. All processes 
must halt eventually or consist of an infinite loop.
* This is a terminator instruction
* This instruction is only allowed in processes (`llhd.proc`).

**Syntax:**
```
halt-op ::= `llhd.halt`
```

**Examples:**
```
llhd.halt
```

### `llhd.neg` (llhd::NegOp)

Negate a value.

The operand and result always have the same type. The type has to be a
signless integer of any width. Although, only signless integers are
allowed, this instruction applies two's complement negation of the
integer, basically treating it as a signed integer.

**Syntax:**
```
neg-op ::= ssa-id `=` `llhd.neg` ssa-value attr-dict `:` type
```

**Examples:**
```
%0 = llhd.const 42 : i32
%1 = llhd.neg %0 : i32
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`value` | signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | signless integer

### `llhd.not` (llhd::NotOp)

Bitwise NOT

Takes an integer of any width or a nine-valued-logic (IEEE 1164) value 
of any width as input. Flips each bit of a value. The result always has 
the exact same type.

**Syntax:**
```
not-op ::= ssa-id `=` `llhd.not` ssa-value attr-dict `:` type
```

**Examples:**
```
%0 = llhd.const 0 : i32
%1 = llhd.not %0 : i32 
```

**Truth Table for `iN`:**

| `not` |  0  |  1  |
|:-----:|:---:|:---:|
|       |  1  |  0  |

**Truth Table for `lN`:**

| `not` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|       |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`value` | signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | signless integer

### `llhd.or` (llhd::OrOp)

Bitwise OR

Takes two integers of the same width or two nine-valued-logic (IEEE 1164)
values of the same width as input. Calculates the bitwise OR. The 
result is always of the exact same type as the two inputs.

**Syntax:**
```
or-op ::= ssa-id `=` `llhd.or` ssa-lhs `,` ssa-rhs attr-dict `:` type
```

**Examples:**
```
%0 = llhd.const 0 : i32
%1 = llhd.or %0, %0 : i32 
```

**Truth Table for `iN`:**

| `or`  |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  1  |
|   1   |  1  |  1  |

**Truth Table for `lN`:**

| `or`  |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  U  |  1  |  U  |  U  |  U  |  1  |  U  |
|   X   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   0   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   1   |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
|   Z   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   W   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   L   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   H   |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
|   -   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | signless integer
`rhs` | signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | signless integer

### `llhd.prb` (llhd::PrbOp)

Probe a signal.

Syntax:

```
operation ::= `llhd.prb` $signal attr-dict `:` type($signal) `->` type(results)
```


The `llhd.prb` instruction probes a signal and returns the value it
currently carries as a new SSA operand. The result type is always
the type carried by the signal.

 **Custom syntax:**

 ```
 prb-op ::= ssa-id `=` `llhd.prb` ssa-sig attr-dict `:` !llhd.sig<type> `->` type
 ```

 **Examples:***

 ```
 %const_i1 = llhd.const 1 : i1
 %sig_i1 = llhd.sig %const_i1 : i1 -> !llhd.sig<i1>
 %prbd = llhd.prb %sig_i1 : !llhd.sig<i1> -> i1
 ```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`signal` | LLHD sig type

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | signless integer

### `llhd.proc` (llhd::ProcOp)




#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`ins` | IntegerAttr | 64-bit signless integer attribute

### `llhd.smod` (llhd::SModOp)

Signed modulo.

This instruction computes the signed modulo of two signless integers of
any width, treating the leading bit as sign. The operand and result
types always have to be the same.
To calculate the signed remainder of two integers, use `remi_signed`
from the standard dialect.

**Syntax:**
```
smod-op ::= ssa-id `=` `llhd.smod` ssa-lhs `,` ssa-rhs attr-dict `:` type
```

**Examples:**
```
%0 = llhd.const 9 : i4
%1 = llhd.const 4 : i4
%2 = llhd.smod %0, %1 : i4
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | signless integer
`rhs` | signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | signless integer

### `llhd.shl` (llhd::ShlOp)

Shifts a value to the left by a given amount.

Syntax:

```
operation ::= `llhd.shl` operands attr-dict `:` functional-type(operands, results)
```


The type of the base value and the hidden value must be the same, but
may differ in the number of bits or elements. The result always has the
same type (including width) of the base value.
The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return 
a signal to the shifted value.
Allowed (underlying) types are signless integers, nine-valued-logic values
and arrays. The shift amount has to be a signless integer. A shift amount
bigger than the number of bits or elements of the hidden value is undefined.
The hidden value is uncovered by non-zero shift amounts. E.g. consider
the four bit values `base = 0xf`, `hidden = 0xc` shifted by an amount of
three result in `0xe`.

**Syntax:**
```
shl-op ::= ssa-id `=` `llhd.shl` ssa-base `,` ssa-hidden `,` ssa-amount attr-dict `:` `(` base-type `,` hidden-type `,` amount-type `)` `->` result-type
```

**Examples:**
```
%0 = llhd.shl %base, %hidden, %amount : (i4, i2, i2) -> i4
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`base` | signless integer or LLHD sig type
`hidden` | signless integer or LLHD sig type
`amount` | signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | signless integer or LLHD sig type

### `llhd.shr` (llhd::ShrOp)

Shifts a value to the right by a given amount.

Syntax:

```
operation ::= `llhd.shr` operands attr-dict `:` functional-type(operands, results)
```


The type of the base value and the hidden value must be the same, but
may differ in the number of bits or elements. The result always has the
same type (including width) of the base value.
The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return 
a signal to the shifted value.
Allowed (underlying) types are signless integers, nine-valued-logic values
and arrays. The shift amount has to be a signless integer. A shift amount
bigger than the number of bits or elements of the hidden value is undefined.
The hidden value is uncovered by non-zero shift amounts. E.g. consider
the four bit values `base = 0xf`, `hidden = 0xc` shifted by an amount of
three result in `0x9`.

**Syntax:**
```
shr-op ::= ssa-id `=` `llhd.shr` ssa-base `,` ssa-hidden `,` ssa-amount attr-dict `:` `(` base-type `,` hidden-type `,` amount-type `)` `->` result-type
```

**Examples:**
```
%0 = llhd.shr %base, %hidden, %amount : (i4, i2, i2) -> i4
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`base` | signless integer or LLHD sig type
`hidden` | signless integer or LLHD sig type
`amount` | signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | signless integer or LLHD sig type

### `llhd.sig` (llhd::SigOp)

Create a signal.

Syntax:

```
operation ::= `llhd.sig` $init attr-dict `:` type($init) `->` type(results)
```


The `llhd.sig` instruction introduces a new signal in the IR. The input 
operand determines the initial value carried by the signal, while the
result type will always be a signal carrying the type of the init operand.
Signals can only be allocated within entities.

**Custom syntax:**

```
sig-op ::= ssa-id `=` `llhd.sig` ssa-init attr-dict `:` init-type `->` !llhd.sig<init-type>
```

**Examples:**

```
%init_i64 = llhd.const 123 : i64
%sig_i64 = llhd.sig %init_64 : i64 -> !llhd.sig<i64>

%init_i1 = llhd.const 1 : i1
%sig_i1 = llhd.sig %init_i1 : i1 -> !llhd.sig<i1>
```
The first `llhd.sig` instruction creates a new signal carrying an `i64` 
type with initial value of 123, while the second one creates a new signal
carrying an `i1` value with initial value of 1.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`init` | signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | LLHD sig type

### `llhd.terminator` (llhd::TerminatorOp)

Dummy terminator

The `"llhd.terminator"` op is a dummy terminator for an `EntityOp` unit. 
It provides no further meaning other than ensuring correct termination 
of an entitiy's region. This operation provides no custom syntax and 
should never explicitly appear in LLHD's custom syntax.

### `llhd.wait` (llhd::WaitOp)

Suspends execution of a process.

The `wait` instruction suspends execution of a process until any of the 
observed signals change or a fixed time interval has passed. Execution
resumes at the specified basic block with the passed arguments.
* This is a terminator instruction.
* This instruction is only allowed in processes (`llhd.proc`).

**Syntax:**
```
wait-op ::= `llhd.wait` ssa-list-obs (`for` ssa-time)? `,` successor-dest ( `(` ssa-list-dest-arguments `:` type-list-dest-arguments `)` )? `:` type-list-obs (`,` type-time)?
```
Notes: 
* `ssa-list-obs`, `ssa-list-dest-arguments`, `type-list-dest-arguments` and `type-list-obs` are comma-separated lists of 0 or more elements.
* In case there is no optional time and `type-list-obs` has zero elements, the last colon is omitted as well.

**Examples:**
```
llhd.wait ^bb1
llhd.wait for %time, ^bb1(%time : !llhd.time) : !llhd.time
llhd.wait %0, %1, ^bb1(%1 : !llhd.sig<i1>) : !llhd.sig<i64>, !llhd.sig<i1>
llhd.wait %0, %1 for %time, ^bb1(%1, %0 : !llhd.sig<i1>, !llhd.sig<i64>) : !llhd.sig<i64>, !llhd.sig<i1>, !llhd.time
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`operand_segment_sizes` | DenseIntElementsAttr | 32-bit signless integer elements attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`obs` | LLHD sig type
`time` | LLHD time type
`destOps` | any type

#### Successors:

| Successor | Description |
| :-------: | ----------- |
`dest` | any successor

### `llhd.xor` (llhd::XorOp)

Bitwise XOR

Takes two integers of the same width or two nine-valued-logic (IEEE 1164)
values of the same width as input. Calculates the bitwise XOR. The 
result is always of the exact same type as the two inputs.

**Syntax:**
```
xor-op ::= ssa-id `=` `llhd.xor` ssa-lhs `,` ssa-rhs attr-dict `:` type
```

**Examples:**
```
%0 = llhd.const 0 : i32
%1 = llhd.xor %0, %0 : i32 
```

**Truth Table for `iN`:**

| `xor` |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  1  |
|   1   |  1  |  0  |

**Truth Table for `lN`:**

| `xor` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  U  |  U  |  U  |  U  |  U  |  U  |  U  |
|   X   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   0   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   1   |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |
|   Z   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   W   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   L   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   H   |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |
|   -   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | signless integer
`rhs` | signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | signless integer

